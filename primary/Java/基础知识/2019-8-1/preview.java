package homeWork7_31;

public class preview {
/**
 * 
 * 1.静态和非静态的区别。（内存）
 * 	a、静态修饰的属性方法和代码块，首先被加载到内存中，位于方法区；被类的所有实例共享，可
 * 	通过类名直接调用；生存周期与类相同；静态成员不能访问非静态成员；非静态成员可以访问静
 * 	态成员。
 * 	b、非静态修饰的变量需要被实例化后才会分配内存于堆中；非静态变量当该变量所在的类被实
 * 	例化后，可通过实例化的类名直接访问；非静态变量的存在周期取决于实例化对象的存在周期。
 * 
 * 2.成员变量和静态变量的区别？
 *  a、所属范围不同：静态变量是属于类范围的，而成员变量属于对象；
 *  b、生存周期不同：类的一生有静态变量伴随，而成员变量只能陪类走一程，对象产生的时候它
 *  就产生，对象消亡他就消亡；
 *  c、存储位置不同，静态变量存储在方法区，而成员变量存储在堆中；
 *  d、调用方式不同，静态变量可以通过类名直接调用，也可以通过对象调用，而成员变量只能通
 *  过对象调用。
 * 
 * 3.静态的特点以及注意事项？
 * 特点：
 * a、静态方法能通过类名直接调用；
 * b、静态属性、方法、代码块优先于对象存在，首先被加载；
 * c、静态方法不能被销毁；
 * d、静态变量随着类的消失而消失，生命周期长；
 * 注意事项：
 * a、静态方法只能访问静态成员；
 * b、静态方法中不能使用this和super关键字；
 * c、主函数main是静态的
 * 
 * 4.什么时候使用静态？
 * a、static修饰成员变量时，如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰；
 * b、匿名内部类用static修饰；
 * c、如果某个方法是用频率较高，或者方法本身通用性较强，无需初始化类成员变量，可修饰为静态方法
 * 
 * 5.super和this的特点？
 * this表示当前对象，也就是当前类对象，super表示当前类的父类。用他们调用父类或子类的构造方
 * 法时，必须放在首行；this和super不能用于static修饰的变量，方法，代码块；this() 和
 * super() 不能存在于同一个构造函数中。
 * 
 * 6.重写和重载的区别？什么时候用重写？什么时候用重载？
 * 区别：
 * a、方法重写要求参数签名必须相同，而方法重载要求参数签名必须不同；
 * b、方法重写要求返回类型必须相同，而方法重载对此不做限制；
 * c、方法重写只能用于子类重写父类的方法，而方法重载用于同一个类的所有方法，包括从父类中继承的
 * 方法；
 * d、方法重写对方法的访问权限和抛出的异常有特殊要求，而方法重载对此不做任何限制；
 * e、父类的一个方法只能被子类重写一次，而一个方法所在的类中可以被多次重载。
 * 
 * 7.类的实例化过程？
 * 通过new创建一个对象，为该对象分配内存，执行该类的构造方法，返回该对象的引用并将其赋值给类
 * 变量。
 * 
 * 8.什么是主函数，主函数为什么要这么定义？详解（public、static、void、main、String[]
 *  args)
 *	主函数即为main函数，是程序执行的起点。
 *	public：因为权限必须是最大的，java虚拟机调用主函数，保证java虚拟机要在任何情况下都
 *	可以访问到主函数。
 *	static：java虚拟机不用创建对象就可以方便的调用main函数，java虚拟机直接用类名就可
 *	以调用。
 *	void：程序运行完毕之后把返回值返回给java虚拟机没有意义。
 *	main:main并不是关键字，只不过是java虚拟机能识别的一个固定的函数名而已。
 *	(String[] args):数组类型的参数,担心某些程序在启动的时候需要参数。
 *
 *	9.final修饰符如何使用？什么是常量？
 *	final可以修饰类，方法和变量，修饰类则该类不能被继承，没有子类；修饰方法时，该方法不能
 *	被重写；修饰变量时，该变量变为常量，只能被赋值一次
 *	

 */

}


